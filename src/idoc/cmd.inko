import idoc.fs (copy_files)
import idoc.ir
import idoc.module_name (ModuleName)
import idoc.page.constant
import idoc.page.method
import idoc.page.module
import idoc.page.modules (self as mods)
import idoc.page.search
import idoc.page.trait (self as trt)
import idoc.page.type (self as typ)
import std.fs.path (Path)
import std.io (Error as IoError, Write)
import std.optparse (Options)
import std.sys (Command, Stream)
import wobsite (Site)

let VERSION = '0.10.0'

# The directory in which to look for the output of `inko doc`.
let INPUT_DIR = 'build/docs'

# The directory to store the output in.
let OUTPUT_DIR = 'build/idoc'

# The path to the directory containing the assets to use.
#
# This constant is public such that its path can be overwritten at compile-time
# (e.g. by setting it to `/usr/share/idoc/assets`).
let pub ASSETS = 'assets'

fn generate_json(
  executable: String,
  private: Bool,
  dependencies: Bool,
) -> Result[Nil, String] {
  let cmd = Command.new(executable)

  cmd.arguments.push('doc')
  cmd.stdin = Stream.Null

  if private { cmd.arguments.push('--private') }

  if dependencies { cmd.arguments.push('--dependencies') }

  let status = try cmd.spawn.then(fn (c) { c.wait }).map_error(fn (e) {
    'failed to start `inko doc`: ${e}'
  })

  if status.success? {
    Result.Ok(nil)
  } else {
    Result.Error(
      'the `inko doc` command exited with status code ${status.to_int}',
    )
  }
}

fn pub run[T: mut + Write[IoError]](
  arguments: Array[String],
  working_directory: ref Path,
  output: mut T,
) -> Result[Nil, String] {
  let opts = Options.new('idoc')

  opts.description = 'Generate documentation for the current project in the form of a static website.

This command automatically invokes `inko doc` to generate the documentation JSON
files used to generate the static website.

Upon completion, the generated files are found in ./build/idoc/public/

Examples:

  idoc                       # Generate documentation for the current project
  idoc path/to/my/project    # Generate documentation for the project in path/to/my/project'

  opts.stop_at_first_non_option = true
  opts.flag('h', 'help', 'Show this help message')
  opts.flag('v', 'version', 'Show the version')
  opts.flag('p', 'private', 'Generate documentation for private symbols')
  opts.flag('d', 'dependencies', 'Generate documentation for dependencies')
  opts.single('c', 'compiler', 'EXE', 'The compiler executable to use')

  let matches = try opts.parse(arguments).map_error(fn (e) { e.to_string })

  if matches.contains?('help') {
    let _ = output.print(opts.to_string)

    return Result.Ok(nil)
  }

  if matches.contains?('version') {
    let _ = output.print('idoc ${VERSION}')

    return Result.Ok(nil)
  }

  try generate_json(
    matches.value('compiler').or('inko'),
    matches.contains?('private'),
    matches.contains?('dependencies'),
  )

  let input = INPUT_DIR.to_path
  let build = OUTPUT_DIR.to_path
  let source = build.join('source')

  # Make sure we always start with a clean directory, instead of keeping files
  # from previous builds around.
  let _ = build.remove_directory_all

  try source.create_directory_all.map_error(fn (e) {
    'failed to create ${source}: ${e}'
  })

  let assets = ASSETS.to_path

  try copy_files(from: assets, to: source).map_error(fn (e) {
    'failed to copy the assets from ${assets} to ${source}: ${e}'
  })

  let site = try Site.new(source, build.join('public')).map_error(fn (e) {
    'failed to set up the site generator: ${e}'
  })

  let (modules, sidebar) = try ir.Module.parse_all(input)
  let search_page = recover search.Page.new
  let mod_summaries = recover []
  let mods_iter = modules.into_iter

  loop {
    let mut mod = match mods_iter.next {
      case Some(v) -> v
      case _ -> break
    }

    mod = recover {
      let mod = recover mod

      search_page.add_symbols(search.Symbol.array_for(mod))
      mod
    }

    let mod_name = ModuleName.new(mod.name)
    let file = mod.file.clone

    mod_summaries.push(
      recover mods.Module.new(mod_name.clone, mod.documentation.summary),
    )

    for c in mod.unique_constants {
      let html = mod_name.symbol_html_uri(c.name)
      let page = recover {
        constant.Page.new(mod_name.clone, file.clone, c, sidebar.clone)
      }

      site.generate(html, fn move (f) { page.to_html(f) })
    }

    for m in mod.unique_methods {
      let html = mod_name.symbol_html_uri(m.name)
      let page = recover method.Page.new(mod_name.clone, m, sidebar.clone)

      site.generate(html, fn move (f) { page.to_html(f) })
    }

    for c in mod.unique_types {
      let html = mod_name.symbol_html_uri(c.name)
      let page = recover typ.Page.new(mod_name.clone, c, sidebar.clone)

      site.generate(html, fn move (f) { page.to_html(f) })
    }

    for c in mod.unique_traits {
      let html = mod_name.symbol_html_uri(c.name)
      let page = recover trt.Page.new(mod_name.clone, c, sidebar.clone)

      site.generate(html, fn move (f) { page.to_html(f) })
    }

    let page = recover module.Page.new(mod_name.source_uri, sidebar.clone, mod)

    site.generate(mod_name.html_uri, fn move (f) { Result.Ok(page.to_html(f)) })
  }

  let index = recover mods.Page.new(input.clone, mod_summaries)

  site.generate('index.html', fn move (f) { index.to_html(f) })
  site.generate('search.json', fn move (f) { Result.Ok(search_page.to_json(f)) })
  site.copy('*.css')
  site.copy('*.js')
  site.copy('*.ico')

  match site.wait {
    case Ok(_) -> Result.Ok(nil)
    case Error(e) -> Result.Error('failed to build the documentation: ${e}')
  }
}
