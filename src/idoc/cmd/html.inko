import idoc.ir (Constant, Module)
import std.fs.file (ReadOnlyFile, WriteOnlyFile)
import std.fs.path (Path)
import std.io (Write)
import std.json (Error, PullParser)
import std.optparse (Help, Options)
import std.range (InclusiveRange)

# The default directory in which to look for the output of `inko doc`.
#
# We default to this directory such that in most cases one can simply run
# `inko doc` followed by `idoc html`, instead of having to run
# `idoc html build/docs`.
let DEFAULT_DIR = 'build/docs'

# The directory to store the output in.
let OUTPUT_DIR = 'build/idoc'

fn usage(options: ref Options, output: mut Write) {
  let help = Help
    .new('idoc html')
    .usage('[OPTIONS] [ARGS]')
    .section('Options')
    .options(options)
    .to_string

  let _ = output.write_string(help)
}

fn run(
  arguments: Array[String],
  working_directory: ref Path,
  output: mut Write,
) -> Result[Nil, String] {
  let opts = Options.new

  opts.flag('h', 'help', 'Show this help message')

  let matches = try opts.parse(arguments).map_error(fn (e) { e.to_string })

  if matches.contains?('help') {
    usage(opts, output)
    return Result.Ok(nil)
  }

  let input = matches.remaining.opt(0).or(DEFAULT_DIR).to_path

  if input.directory?.false? { throw "the directory '${input}' doesn't exist" }

  # TODO:
  #
  # - Parse the JSON files
  # - Convert the JSON data to Markdown files, one for each module. Write these
  #   build/idoc/source/
  # - Adjust the headings in examples to be of the right level
  # - Do all this in parallel
  # - Copy assets (e.g. CSS) from /usr/share/whatever to build/idoc/source/
  # - Generate static website using inko-wobsite, write to build/idoc/public/

  let files = try input
    .list
    .then(fn (iter) {
      iter.try_reduce([], fn (acc, res) {
        match res {
          case Ok({ @path = path, @type = File }) -> {
            match path.extension {
              case Some('json') -> acc.push(path)
              case _ -> {}
            }
          }
          case Error(e) -> throw e
          case _ -> {}
        }

        Result.Ok(acc)
      })
    })
    .map_error(fn (e) { 'failed to get the JSON input files: ${e}' })

  let dir = OUTPUT_DIR.to_path
  let md_dir = dir.join('source/modules')

  try md_dir.create_directory_all.map_error(fn (e) {
    "failed to create '${md_dir}': ${e}"
  })

  try files.into_iter.try_each(fn (path) {
    try Module.parse_file(path.clone).map_error(fn (e) {
      'failed to parse ${path}: ${e}'
    })

    Result.Ok(nil)
  })

  Result.Ok(nil)
}
