import std.fs.file (ReadOnlyFile, WriteOnlyFile)
import std.fs.path (Path)
import std.io (Write)
import std.json (PullParser)
import std.optparse (Help, Options)
import std.range (InclusiveRange)

# The default directory in which to look for the output of `inko doc`.
#
# We default to this directory such that in most cases one can simply run
# `inko doc` followed by `idoc html`, instead of having to run
# `idoc html build/docs`.
let DEFAULT_DIR = 'build/docs'

# The directory to store the output in.
let OUTPUT_DIR = 'build/idoc'

class Location {
  let @lines: InclusiveRange
  let @columns: InclusiveRange
}

class Module {
  let @name: String
  let @file: Path
  let @documentation: String
}

class Constant {
  let @name: String
  let @location: Location
  let @public: Bool
  let @type: String
  let @documentation: String
}

class Field {
  let @name: String
  let @location: Location
  let @public: Bool
  let @type: String
  let @documentation: String
}

class Constructor {
  let @name: String
  let @location: Location
  let @type: String
  let @documentation: String
}

class enum MethodKind {
  case Instance
  case Mutable
  case Moving
  case Async
  case AsyncMutable
  case Destructor
  case Static
  case Extern

  fn static from(value: Int) -> MethodKind {
    match value {
      case 1 -> MethodKind.Mutable
      case 2 -> MethodKind.Moving
      case 3 -> MethodKind.Async
      case 4 -> MethodKind.AsyncMutable
      case 5 -> MethodKind.Destructor
      case 6 -> MethodKind.Static
      case 7 -> MethodKind.Extern
      case _ -> MethodKind.Instance
    }
  }
}

class Method {
  let @name: String
  let @kind: MethodKind
  let @file: Path
  let @location: Location
  let @public: Bool
  let @type: String
  let @documentation: String
}

class enum ClassKind {
  case Regular
  case Enum
  case Async
  case Extern
  case Tuple
  case ValueType
  case Atomic

  fn static from(value: Int) -> ClassKind {
    match value {
      case 1 -> ClassKind.Enum
      case 2 -> ClassKind.Async
      case 3 -> ClassKind.Extern
      case 4 -> ClassKind.Tuple
      case 5 -> ClassKind.ValueType
      case 6 -> ClassKind.Atomic
      case _ -> ClassKind.Regular
    }
  }
}

class Class {
  let @name: String
  let @kind: ClassKind
  let @file: Path
  let @location: Location
  let @public: Bool
  let @type: String
  let @documentation: String
  let @fields: Array[Field]
  let @methods: Array[Method]
}

fn usage(options: ref Options, output: mut Write) {
  let help = Help
    .new('idoc html')
    .usage('[OPTIONS] [ARGS]')
    .section('Options')
    .options(options)
    .to_string

  let _ = output.write_string(help)
}

fn run(
  arguments: Array[String],
  working_directory: ref Path,
  output: mut Write,
) -> Result[Nil, String] {
  let opts = Options.new

  opts.flag('h', 'help', 'Show this help message')

  let matches = try opts.parse(arguments).map_error(fn (e) { e.to_string })

  if matches.contains?('help') {
    usage(opts, output)
    return Result.Ok(nil)
  }

  let input = matches.remaining.opt(0).or(DEFAULT_DIR).to_path

  if input.directory?.false? { throw "the directory '${input}' doesn't exist" }

  # TODO:
  #
  # - Parse the JSON files
  # - Convert the JSON data to Markdown files, one for each module. Write these
  #   build/idoc/source/
  # - Adjust the headings in examples to be of the right level
  # - Copy assets (e.g. CSS) from /usr/share/whatever to build/idoc/source/
  # - Generate static website using inko-wobsite, write to build/idoc/public/

  let files = try input
    .list
    .then(fn (iter) {
      iter.try_reduce([], fn (acc, res) {
        match res {
          case Ok({ @path = path, @type = File }) -> {
            match path.extension {
              case Some('json') -> acc.push(path)
              case _ -> {}
            }
          }
          case Error(e) -> throw e
          case _ -> {}
        }

        Result.Ok(acc)
      })
    })
    .map_error(fn (e) { 'failed to get the JSON input files: ${e}' })

  let dir = OUTPUT_DIR.to_path
  let md_dir = dir.join('source/modules')

  try md_dir.create_directory_all.map_error(fn (e) {
    "failed to create '${md_dir}': ${e}"
  })

  try files.into_iter.try_each(fn (path) {
    let bytes = ByteArray.new

    try ReadOnlyFile
      .new(path.clone)
      .then(fn (f) { f.read_all(bytes) })
      .map_error(fn (e) { "failed to read '${path}': ${e}" })

    let parser = PullParser.new(bytes)
    let module = Module(name: '', file: ''.to_path, documentation: '')

    # TODO: the order is random, so we have to buffer the data as intermediate
    # values.
    try parser
      .object
      .string('name', fn (v) { module.name = v })
      .string('file', fn (v) { module.file = v.to_path })
      .string('documentation', fn (v) { module.documentation = v })
      .values('constants', fn {
        let const = Constant(
          name: '',
          location: Location(lines: 1.to(1), columns: 1.to(1)),
          public: false,
          type: '',
          documentation: '',
        )

        parser
          .object
          .string('name', fn (v) { const.name = v })
          .key('location', fn {
            parser
              .object
              .key('lines', fn {
                parser
                  .object
                  .int('start', fn (v) { const.location.lines.start = v })
                  .int('end', fn (v) { const.location.lines.end = v })
                  .parse
              })
              .key('columns', fn {
                parser
                  .object
                  .int('start', fn (v) { const.location.columns.start = v })
                  .int('end', fn (v) { const.location.columns.end = v })
                  .parse
              })
              .parse
          })
          .bool('public', fn (v) { const.public = v })
          .string('type', fn (v) { const.type = v })
          .string('documentation', fn (v) { const.documentation = v })
          .parse
      })
      .parse
      .map_error(fn (e) { 'failed to parse the JSON: ${e}' })

    Result.Ok(nil)
  })

  # let docs = files
  #   .into_iter
  #   .try_reduce([], fn (acc, path) { Result.Ok(acc) })
  #   .map_error(fn (e) { 'failed to parse the JSON files: ${e}' })

  Result.Ok(nil)
}
